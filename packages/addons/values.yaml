argocd:
  enabled: true
  chartName: argo-cd
  namespace: argocd
  releaseName: argocd
  defaultVersion: "8.0.14"
  chartRepository: "https://argoproj.github.io/argo-helm"
  valuesObject:
    global:
      domain: '{{ if eq .metadata.annotations.pathRouting "true" }}{{ .metadata.annotations.domain }}{{ else }}argocd.{{ .metadata.annotations.domain }}{{ end }}'
    server:
      ingress:
        annotations:
          cert-manager.io/cluster-issuer: '{{ if eq .metadata.annotations.pathRouting "false" }}letsencrypt-{{ .metadata.annotations.letsencryptEnv }}{{ end }}'
        path: '/{{ if eq .metadata.annotations.pathRouting "true" }}argocd{{ end }}'
    configs:
      cm:
        oidc.config: |
          name: Keycloak
          issuer: https://{{ if eq .metadata.annotations.pathRouting "false" }}keycloak.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}/keycloak{{ end }}/realms/cnoe
          clientID: argocd
          enablePKCEAuthentication: true
          requestedScopes:
            - openid
            - profile
            - email
            - groups
      params:
        "server.basehref": '/{{ if eq .metadata.annotations.pathRouting "true" }}argocd{{ end }}'
        "server.rootpath": '{{ if eq .metadata.annotations.pathRouting "true" }}argocd{{ end }}'
  additionalResources:
    - manifestPath: "manifests"
      type: "manifests"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane-bootstrap", "control-plane"]

crossplane:
  enabled: true
  chartName: crossplane
  namespace: crossplane-system
  releaseName: crossplane
  defaultVersion: "2.0.2-up.4"
  chartRepository: "https://charts.upbound.io/stable"
  valuesObject:
    customLabels:
      azure.workload.identity/use: "true"
    serviceAccount:
      customAnnotations:
        azure.workload.identity/client-id: "{{ .metadata.annotations.crossplaneClientId }}"
        azure.workload.identity/tenant-id: "{{ .metadata.annotations.crossplaneTenantId }}"
    extraObjects:
      - apiVersion: azure.m.upbound.io/v1beta1
        kind: ClusterProviderConfig
        metadata:
          name: default
          annotations:
            argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
        spec:
          credentials:
            source: OIDCTokenFile
            # source: UserAssignedManagedIdentity
          oidcTokenFilePath: /var/run/secrets/azure/tokens/azure-identity-token
          subscriptionID: "{{ .metadata.annotations.subscription }}"
          clientID: "{{ .metadata.annotations.crossplaneClientId }}"
          tenantID: "{{ .metadata.annotations.crossplaneTenantId }}"
      - apiVersion: azure.livewyer.io/v1alpha1
        kind: WorkloadIdentity
        metadata:
          name: external-dns
          namespace: external-dns
          annotations:
            argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
        spec:
          forProvider:
            location: "{{ .metadata.annotations.location }}"
            oidcIssuerURL: "{{ .metadata.annotations.clusterOIDCIssuerURL }}"
            resourceGroupName: "{{ .metadata.annotations.resourceGroup }}"
            roleAssignments:
              - roleDefinitionName: DNS Zone Contributor
                scope: "/subscriptions/{{ .metadata.annotations.subscription }}/resourceGroups/{{ .metadata.annotations.resourceGroup }}/providers/Microsoft.Network/dnszones/{{ .metadata.annotations.domain }}"
            serviceAccountName: external-dns
      - apiVersion: azure.livewyer.io/v1alpha1
        kind: WorkloadIdentity
        metadata:
          name: external-secrets
          namespace: external-secrets
          annotations:
            argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
        spec:
          forProvider:
            location: "{{ .metadata.annotations.location }}"
            oidcIssuerURL: "{{ .metadata.annotations.clusterOIDCIssuerURL }}"
            resourceGroupName: "{{ .metadata.annotations.resourceGroup }}"
            roleAssignments:
              - roleDefinitionName: Key Vault Administrator
                scope: "/subscriptions/{{ .metadata.annotations.subscription }}/resourceGroups/{{ .metadata.annotations.resourceGroup }}/providers/Microsoft.KeyVault/vaults/{{ .metadata.annotations.keyvault }}"
            serviceAccountName: workload-identity-sa
      - apiVersion: azure.livewyer.io/v1alpha1
        kind: WorkloadIdentity
        metadata:
          name: keycloak
          namespace: keycloak
          annotations:
            argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
        spec:
          forProvider:
            location: "{{ .metadata.annotations.location }}"
            oidcIssuerURL: "{{ .metadata.annotations.clusterOIDCIssuerURL }}"
            resourceGroupName: "{{ .metadata.annotations.resourceGroup }}"
            roleAssignments:
              - roleDefinitionName: Key Vault Administrator
                scope: "/subscriptions/{{ .metadata.annotations.subscription }}/resourceGroups/{{ .metadata.annotations.resourceGroup }}/providers/Microsoft.KeyVault/vaults/{{ .metadata.annotations.keyvault }}"
            serviceAccountName: eso-store
  additionalResources:
    - manifestPath: "manifests"
      type: "manifests"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

ingress-nginx:
  enabled: true
  chartName: ingress-nginx
  namespace: ingress-nginx
  releaseName: ingress-nginx
  defaultVersion: "4.7.0"
  chartRepository: "https://kubernetes.github.io/ingress-nginx"
  valuesObject:
    controller:
      service:
        type: LoadBalancer
        externalTrafficPolicy: Local
        annotations:
          service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: /healthz
        targetPorts:
          https: "https"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

external-dns:
  enabled: true
  releaseName: external-dns
  namespace: external-dns
  chartName: external-dns
  chartRepository: https://kubernetes-sigs.github.io/external-dns
  defaultVersion: "1.16.1"
  valuesObject:
    provider:
      name: azure
    domainFilters:
      - "{{ .metadata.annotations.domain }}"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

external-secrets:
  enabled: true
  namespace: external-secrets
  chartName: external-secrets
  defaultVersion: "0.17.0"
  chartRepository: "https://charts.external-secrets.io"
  valuesObject:
    extraObjects:
      - apiVersion: external-secrets.io/v1
        kind: ClusterSecretStore
        metadata:
          name: azure-keyvault
        spec:
          provider:
            azurekv:
              authType: WorkloadIdentity
              vaultUrl: "https://{{ .metadata.annotations.keyvault }}.vault.azure.net"
              serviceAccountRef:
                name: workload-identity-sa
                namespace: external-secrets
      - apiVersion: external-secrets.io/v1
        kind: ClusterSecretStore
        metadata:
          name: keycloak
          annotations:
            argocd.argoproj.io/sync-wave: "60"
        spec:
          provider:
            kubernetes:
              remoteNamespace: keycloak
              server:
                caProvider:
                  type: ConfigMap
                  name: kube-root-ca.crt
                  namespace: keycloak
                  key: ca.crt
              auth:
                serviceAccount:
                  name: eso-store
                  namespace: keycloak
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane-bootstrap", "control-plane"]

cert-manager:
  enabled: true
  chartName: cert-manager
  namespace: cert-manager
  releaseName: cert-manager
  defaultVersion: "1.17.2"
  chartRepository: "https://charts.jetstack.io"
  valuesObject:
    global:
      domainName: '{{ if eq .metadata.annotations.pathRouting "true" }}{{ .metadata.annotations.domain }}{{ end }}'
      pathRouting: '{{ if eq .metadata.annotations.pathRouting "true" }}true{{ else }}false{{ end }}'
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

keycloak:
  enabled: true
  chartName: keycloak
  namespace: keycloak
  releaseName: keycloak
  defaultVersion: "24.7.3"
  chartRepository: "https://charts.bitnami.com/bitnami"
  valuesObject:
    httpRelativePath: '/{{ if eq .metadata.annotations.pathRouting "true" }}keycloak/{{ end }}'
    ingress:
      hostname: '{{ if eq .metadata.annotations.pathRouting "false" }}keycloak.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}{{ end }}'
      annotations:
        cert-manager.io/cluster-issuer: '{{ if eq .metadata.annotations.pathRouting "false" }}letsencrypt-{{ .metadata.annotations.letsencryptEnv }}{{ end }}'
      extraTls:
        - hosts:
            - '{{ if eq .metadata.annotations.pathRouting "false" }}keycloak.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}{{ end }}'
          secretName: keycloak-server-tls
  additionalResources:
    - manifestPath: "manifests"
      type: "manifests"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

backstage:
  enabled: true
  chartName: backstage
  namespace: backstage
  releaseName: backstage
  defaultVersion: "2.6.0"
  chartRepository: "https://backstage.github.io/charts"
  valuesObject:
    ingress:
      host: '{{ if eq .metadata.annotations.pathRouting "false" }}backstage.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}{{ end }}'
      annotations:
        cert-manager.io/cluster-issuer: '{{ if eq .metadata.annotations.pathRouting "false" }}letsencrypt-{{ .metadata.annotations.letsencryptEnv }}{{ end }}'
    backstage:
      appConfig:
        catalog:
          locations:
            - type: url
              target: "{{ .metadata.annotations.addonsRepoURL }}/blob/{{ .metadata.annotations.addonsRepoRevision }}/templates/backstage/catalog-info.yaml"
      extraEnvVars:
        - name: BACKSTAGE_FRONTEND_URL
          value: 'https://{{ if eq .metadata.annotations.pathRouting "false" }}backstage.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}{{ end }}'
        - name: KEYCLOAK_NAME_METADATA
          value: 'https://{{ if eq .metadata.annotations.pathRouting "false" }}keycloak.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}/keycloak{{ end }}/realms/cnoe/.well-known/openid-configuration'
        - name: ARGO_WORKFLOWS_URL
          value: 'https://{{ if eq .metadata.annotations.pathRouting "false" }}argo-workflows.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}/argo-workflows{{ end }}'
        - name: ARGO_CD_URL
          value: 'https://{{ if eq .metadata.annotations.pathRouting "false" }}argocd.{{ .metadata.annotations.domain }}{{ else }}{{ .metadata.annotations.domain }}/argocd{{ end }}'
  additionalResources:
    - manifestPath: "manifests"
      type: "manifests"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

argo-workflows:
  enabled: true
  chartName: argo-workflows
  namespace: argo
  releaseName: argo-workflows
  defaultVersion: "0.45.18"
  chartRepository: "https://argoproj.github.io/argo-helm"
  valuesObject:
    server:
      baseHref: '/{{ if eq .metadata.annotations.pathRouting "true" }}argo-workflows/{{ end }}'
      sso:
        issuer: '{{ if eq .metadata.annotations.pathRouting "true" }}https://{{ .metadata.annotations.domain }}/keycloak{{ else }}https://keycloak.{{ .metadata.annotations.domain }}{{ end }}/realms/cnoe'
        redirectUrl: '{{ if eq .metadata.annotations.pathRouting "true" }}https://{{ .metadata.annotations.domain }}/argo-workflows{{ else }}https://argo-workflows.{{ .metadata.annotations.domain }}{{ end }}/oauth2/callback'
      ingress:
        annotations:
          cert-manager.io/cluster-issuer: '{{ if eq .metadata.annotations.pathRouting "false" }}letsencrypt-{{ .metadata.annotations.letsencryptEnv }}{{ end }}'
          nginx.ingress.kubernetes.io/rewrite-target: '{{ if eq .metadata.annotations.pathRouting "true" }}/$2{{ end }}'
        hosts:
          - '{{ if eq .metadata.annotations.pathRouting "true" }}{{ .metadata.annotations.domain }}{{ else }}argo-workflows.{{ .metadata.annotations.domain }}{{ end }}'
        paths:
          - '/{{ if eq .metadata.annotations.pathRouting "true" }}argo-workflows(/|$)(.*){{ end }}'
        tls:
          - hosts:
              - '{{ if eq .metadata.annotations.pathRouting "true" }}{{ .metadata.annotations.domain }}{{ else }}argo-workflows.{{ .metadata.annotations.domain }}{{ end }}'
            secretName: argo-workflows-server-tls
  additionalResources:
    - manifestPath: "manifests"
      type: "manifests"
  selector:
    matchExpressions:
      - key: environment
        operator: In
        values: ["control-plane"]

syncPolicy:
  automated:
    selfHeal: true
    allowEmpty: true
    prune: false

syncPolicyAppSet:
  preserveResourcesOnDeletion: false # Set to false so that cleanup script removes all the deployed resources
